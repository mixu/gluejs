#!/usr/bin/env node
var fs = require('fs'),
    path = require('path'),
    Glue = require('../index.js');

var opts = require('yargs')
    .usage('Usage: $0 --include <file/dir ...> --out filename.js')
    .options({
      'basepath': { 'default': process.cwd() },
      'cache': { default: true },
      'cache-method': { },
      'cache-path': { },
      'command': { },
      'config': { },
      'exclude': { },
      'exclude-regexp': { },
      'global': { },
      'global-require': { },
      'ignore': { },
      'include': { },
      'jobs': { },
      'out': { },
      'remap': { },
      'replace': { },
      'silent': { },
      'source-map': { },
      'source-url': { },
      'verbose': { },
      'version': { }
    })
    .boolean('amd')
    .boolean('cache')
    .boolean('debug')
    .boolean('export-config')
    .boolean('insert-globals')
    .boolean('ls-config')
    .boolean('progress')
    .boolean('report')
    .boolean('source-map')
    .boolean('source-url')
    .boolean('umd')
    .boolean('verbose'),
    argv = opts.parse(process.argv);

if(argv['version'] || argv['v'] ) {
  console.log(require('../package.json').version);
  process.exit();
}

var g = new Glue(),
    config = {};

if(!argv['include'] && !argv['config']) {
  return fs.createReadStream(__dirname + '/usage.txt').pipe(process.stdout).on('close', function () { process.exit(1) });
}

// set logging levels early, so that all messages are shown
// Logging level (exclusive):
// --verbose: Enable verbose logging
// --debug: Enable debug logging
var logLevel = 'warn';
if (argv['verbose']) {
  logLevel = 'info';
}
if (argv['debug']) {
  logLevel = 'debug';
}
if (argv['silent'] || !process.stdout.isTTY) {
  logLevel = 'error';
}
config['log'] = argv['log'] || logLevel;

// Logging reporters:
// --silent: no reporter
// --progress: progress report (enabled by default)
// --report: size report
// --list: file list, disables others
if (argv['silent']) {
  // no reporters
  // do not alter the config reporters if --config is set
} else if (argv['list']) {
  config['list'] = true;
  config['log'] = 'error';
} else {
  ['progress', 'report'].forEach(function(key) {
    if (typeof argv[key] !== 'undefined') {
      config[key] = argv[key];
    }
  });
  // if --out filename and not --silent, enable the progress reporter
  var isWriteToFile = (argv['out'] && process.stderr.isTTY),
      hasHighVerbosity = (logLevel == 'debug' || logLevel == 'info'),
      hasConfig = !!argv['config'];
  if (isWriteToFile && !hasHighVerbosity && !hasConfig) {
    config['progress'] = true;
  }
}

// for amd and source-url, delete if explicitly set
if (!argv['amd']) {
  delete argv['amd'];
}
if (!argv['source-url']) {
  delete argv['source-url'];
}

// Boolean params:
[
  'amd',
  'cache',
  'debug',
  'global-require',
  'insert-globals',
  'source-map',
  'source-url',
  'umd',
  'verbose'
  ].forEach(function(key) {
    if (typeof argv[key] !== 'undefined') {
      config[key] = !!argv[key];
    }
});

// Allow the following params to be specified with a ,
// Also accept multiple param groups: --foo a,b,c --foo d,e,f
[ 'include', 'exclude', 'ignore', 'remap', 'replace'].forEach(function(key) {
  if (!argv[key]) {
    return;
  }
  argv[key] = (Array.isArray(argv[key]) ? argv[key] : [ argv[key] ]).reduce(function(prev, curr) {
    return prev.concat(curr.split(','));
  }, []);
});

// String params:
[
  'basepath',
  'cache-method',
  'command',
  'exclude',
  'exclude-regexp',
  'ignore',
  'include',
  'jobs',
  'log',
  'out',
  'transform'
  ].forEach(function(key) {
  if(argv[key]) {
    config[key] = argv[key];
  }
});

// --global
config['export'] = argv['global'];

// --remap
['replace', 'remap'].forEach(function(key) {
  if (!argv[key]) {
    return;
  }
  // allow --remap foo=bar,baz=abc or --remap foo=bar --remap bar=abc
  var values = {};

  argv[key].forEach(function(item) {
    var pos = item.indexOf('='),
        name = item.substring(0, pos),
        value = item.substring(pos+1);
    values[name] = value;
  });
  if (Object.keys(values).length > 0) {
    config[key] = values;
  }
});

if(argv['cache-path']) {
  config['cache-path'] = path.resolve(process.cwd(), argv['cache-path']);
}

if (argv['config']) {
  var loaded;
  argv.config = path.resolve(process.cwd(), argv['config']);
  if (fs.existsSync(argv.config)) {
    loaded = require(argv.config);
    Object.keys(config).forEach(function(key) {
      if (loaded[key] != config[key] && typeof config[key] !== 'undefined') {
        loaded[key] = config[key];
        // console.error('set', key, config[key]);
      }
    });
    config = loaded;
  } else {
    console.error('Failed to load config file:', argv.config);
    process.exit(1);
  }
}

if(argv['export-config'] || argv['ls-config']) {
  var sorted = {};
  Object.keys(config).sort().forEach(function(key) {
    sorted[key] = config[key];
  });
  if (argv['ls-config']) {
    console.error('\nOptions:');
    Object.keys(sorted).forEach(function(key) {
      console.error('  --' + key + ' ' + require('util').inspect(sorted[key], null, 20, process.stderr.isTTY));
    });
  }
  if (argv['export-config']) {
    console.error(JSON.stringify(sorted, null, 2));
    process.exit();
  }
}

g.set(config);

// -- out
if(config['out']) {
  g.render(fs.createWriteStream(config['out']));
} else {
  g.render(process.stdout);
}
